# -*- coding: utf-8 -*-
"""Autonomous Exploration.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R-vmmORLjlQRczr0p8Ov5pvMciXpOMYK

1) Create Map
"""

import numpy as np
import matplotlib.pyplot as plt

# create a map with 0s representing free space
mapSize = (10, 10)
map = np.zeros(mapSize)

# add in obstacles where 1s represent obstacle
map[0:5, 3] = 1
map[7, 0:5] = 1
map [2, 1] = 1
map [5, 5] = 1

print(map)

"""2) Create Robot Class"""

class Robot:
    def __init__(self, startPosition):
        self.position = np.array(startPosition, dtype=float)
        self.path = [startPosition]
        self.sensorRange = 1  # Change to determine how big the sensor radius is
        self.step_size = 1  # Step size for continuous movement
        self.collision_threshold = 0.5  # Threshold distance to consider a collision

    def move(self, direction):
        """Move in continuous space based on the direction."""
        if direction == 0:  # Up
            newPosition = self.position + [-self.step_size, 0]
        elif direction == 1:  # Down
            newPosition = self.position + [self.step_size, 0]
        elif direction == 2:  # Left
            newPosition = self.position + [0, -self.step_size]
        elif direction == 3:  # Right
            newPosition = self.position + [0, self.step_size]

        if self.isValidPosition(newPosition):
            self.position = newPosition
            self.path.append(newPosition.tolist())
            return True
        else:
            return False

    def isValidPosition(self, newPosition):
        """Checks if position is valid based on distance to obstacles and map boundaries"""
        # Check if within bounds
        if newPosition[0] < 0 or newPosition[0] >= mapSize[0] or newPosition[1] < 0 or newPosition[1] >= mapSize[1]:
            return False

        # Check if any intermediate points between current position and new position hit an obstacle
        steps = int(np.ceil(np.linalg.norm(newPosition - self.position) / self.step_size))
        for step in range(steps + 1):
            interp_position = self.position + step * (newPosition - self.position) / steps
            discrete_position = np.floor(interp_position).astype(int)
            # Check if inbounds
            if not (0 <= discrete_position[0] < mapSize[0] and 0 <= discrete_position[1] < mapSize[1]):
                return False
            # Check if an obstacle
            if map[discrete_position[0], discrete_position[1]] == 1:
                return False

        return True

    def sense(self):
        """Senses the environment around the robot in a continuous manner"""
        obstacles = set()  # Using a set to avoid duplicates
        angle_resolution = 720  # Finer angle resolution for increased detection
        for angle in np.linspace(0, 2 * np.pi, angle_resolution):  # Checks 360 degrees around the robot
            for r in np.arange(0, self.sensorRange + self.step_size, self.step_size):  # Checks distance increments of sensorRange
                pos_to_check = self.position + r * np.array([np.cos(angle), np.sin(angle)])
                discrete_pos_to_check = np.round(pos_to_check).astype(int)  # Use np.round for better accuracy
                if 0 <= discrete_pos_to_check[0] < mapSize[0] and 0 <= discrete_pos_to_check[1] < mapSize[1]:
                    if map[discrete_pos_to_check[0], discrete_pos_to_check[1]] == 1:
                        obstacles.add(tuple(discrete_pos_to_check))
                        break  # Stop checking further along this angle as an obstacle is found
        return list(obstacles)

# Initialize the robot at the starting position (0, 0)
robot = Robot(startPosition=(0, 0))

"""3) Simulate Movement on Map"""

# Valid path
valid_movements = [3, 3, 1, 1, 1, 1, 1, 3, 3, 1, 3, 1, 1, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3]

obstacles = []
i = 0
for move in valid_movements:
    senses = robot.sense()
    print(f"Obstacles at {i}th iteration: ", senses)
    # for sense in senses: #need when building entire map
    #   obstacles.append(sense)
    if not robot.move(move):
        break
    i += 1
# print(obstacles)

path = np.array(robot.path)
print(path)

plt.imshow(map, cmap='gray')
plt.plot(path[:, 1], path[:, 0], marker='o', color='r')
plt.title('Robot Path')
plt.show()

# Tomorrow: add in A* movement to see if obstacle tracking, obstacle avoidance, and path tracking work. Potentially add random map generator