# -*- coding: utf-8 -*-
"""Autonomous Exploration.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R-vmmORLjlQRczr0p8Ov5pvMciXpOMYK

1) Create Map
"""

import numpy as np
import matplotlib.pyplot as plt
from heapq import heappop, heappush

# Constants describing map
UNKNOWN = -1
FREE_SPACE = 0
OBSTACLE = 1

# will use later after I figure out exploration algorithm
# def generateRandomMap(mapSize, numObstacles):
#     """Generates a random map with obstacles"""
#     map = np.zeros(mapSize)
#     obstacles = set()
#     while len(obstacles) < numObstacles:
#         obstacle = (np.random.randint(0, mapSize[0]), np.random.randint(0, mapSize[1]))
#         if obstacle != (0, 0) and obstacle != (mapSize[0] - 1, mapSize[1] - 1):
#             obstacles.add(obstacle)
#     for obstacle in obstacles:
#         map[obstacle] = OBSTACLE
#     return map

def generateFixedMap():
    """Generates a fixed small map with obstacles"""
    map = np.zeros((10, 10))
    obstacles = [
        (1, 2), (2, 2), (3, 2),
        (6, 5), (7, 5), (8, 5),
        (4, 8), (4, 9), (5, 9)
    ]
    for obstacle in obstacles:
        map[obstacle] = 1
    return map

def initializeRobotMap(mapSize):
    """Initializes the robot map with unknown values"""
    return np.full(mapSize, UNKNOWN)

"""2) Create Robot Class"""

class Robot:
    def __init__(self, startPosition):
        self.position = np.array(startPosition, dtype=float)
        self.path = [startPosition]
        self.sensorRange = 1  # Change to determine how big the sensor radius is
        self.step_size = 1  # Step size for continuous movement
        self.collision_threshold = 0.5  # Threshold distance to consider a collision
        self.globalSenseDict = {}

    def isValidPosition(self, newPosition):
        """Checks if position is valid based on distance to obstacles and map boundaries"""
        # Check if within bounds
        if newPosition[0] < 0 or newPosition[0] >= mapSize[0] or newPosition[1] < 0 or newPosition[1] >= mapSize[1]:
            return False

        # Check if any intermediate points between current position and new position hit an obstacle
        steps = int(np.ceil(np.linalg.norm(newPosition - self.position) / self.step_size))
        for step in range(steps + 1):
            interp_position = self.position + step * (newPosition - self.position) / steps
            discrete_position = np.floor(interp_position).astype(int)
            # Check if inbounds
            if not (0 <= discrete_position[0] < mapSize[0] and 0 <= discrete_position[1] < mapSize[1]):
                return False
            # Check if an obstacle
            if map[discrete_position[0], discrete_position[1]] == OBSTACLE:
                return False
        return True

    def sense(self, robotMap):
        """Senses the environment around the robot in a continuous manner to build robotMap"""
        currSenseDict = {}
        angle_resolution = 360  # Reduced angle resolution to speed up sensing
        for angle in np.linspace(0, 2 * np.pi, angle_resolution):  # Checks 360 degrees around the robot
            for r in np.arange(0, self.sensorRange + self.step_size, self.step_size):  # Checks distance increments of sensorRange
                pos_to_check = self.position + r * np.array([np.cos(angle), np.sin(angle)])
                discrete_pos_to_check = tuple(np.round(pos_to_check).astype(int))  # Use np.round for better accuracy
                if 0 <= discrete_pos_to_check[0] < mapSize[0] and 0 <= discrete_pos_to_check[1] < mapSize[1]:  # If in-bounds, check position
                    if robotMap[discrete_pos_to_check[0], discrete_pos_to_check[1]] == UNKNOWN:  # If unknown on robotMap
                        if map[discrete_pos_to_check[0], discrete_pos_to_check[1]] == OBSTACLE:  # Check actual map if obstacle
                            robotMap[discrete_pos_to_check[0], discrete_pos_to_check[1]] = OBSTACLE  # Update robotMap
                            currSenseDict[discrete_pos_to_check] = 'obstacle'  # Update Local Dict
                            self.globalSenseDict[discrete_pos_to_check] = 'obstacle'  # Update globalSenseDict
                        else:  # Or check if free
                            robotMap[discrete_pos_to_check[0], discrete_pos_to_check[1]] = FREE_SPACE
                            currSenseDict[discrete_pos_to_check] = 'free'
                            self.globalSenseDict[discrete_pos_to_check] = 'free'
        return currSenseDict

    def move(self, newPos):
        newPos = np.array(newPos, dtype=float)
        while not np.array_equal(self.position, newPos):  # While goal hasn't been reached
            direction = np.sign(newPos - self.position)
            newPosition = self.position + direction * self.step_size
            if self.isValidPosition(newPosition):
                self.position = newPosition
                self.path.append(newPosition.tolist())
            else:
                break

    def findPath(self, pos, goal, robotMap):
        path = a_star(robotMap, pos, goal, self.step_size)
        if path:
            for pos in path:
                self.sense(robotMap)
                self.move(pos)
                self.globalSenseDict[tuple(pos)] = 'free'  # While moving, set everything in path to be known as free

"""3) Simulate Movement on Map"""

def identifyFrontiers(robotMap):
    """Identifies frontiers in the robot map based on current position"""
    frontiers = []
    for r in range(robotMap.shape[0]):
        for c in range(robotMap.shape[1]):
            if robotMap[r, c] == UNKNOWN:
                if any(robotMap[r+dr, c+dc] == FREE_SPACE for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)] if 0 <= r+dr < robotMap.shape[0] and 0 <= c+dc < robotMap.shape[1]):
                    frontiers.append((r, c))
    return frontiers

def nearestFrontier(currPos, frontiers):
    """Finds the nearest frontier from the current position"""
    distances = [np.linalg.norm(np.array(frontier) - np.array(currPos)) for frontier in frontiers]
    return frontiers[np.argmin(distances)]

def heuristic(a, b):
    return np.linalg.norm(np.array(a) - np.array(b))

def a_star(map, pos, goal, stepSize=0.25):
    def get_neighbors(pos):
        """Explore in 8 directions for neighboring states"""
        directions = [(stepSize, 0), (-stepSize, 0), (0, stepSize), (0, -stepSize),
                      (stepSize, stepSize), (stepSize, -stepSize), (-stepSize, stepSize), (-stepSize, -stepSize)]
        neighbors = []
        for direction in directions:
            neighbor = (pos[0] + direction[0], pos[1] + direction[1])
            if 0 <= neighbor[0] < map.shape[0] and 0 <= neighbor[1] < map.shape[1] and map[int(neighbor[0]), int(neighbor[1])] != OBSTACLE:
                neighbors.append(tuple(neighbor))
        return neighbors

    pos = tuple(pos)
    goal = tuple(goal)
    exploredSet = set()
    cameFrom = {}  # Used to reconstruct path
    gScore = {pos: 0}
    fscore = {pos: heuristic(pos, goal)}
    frontier = []
    heappush(frontier, (fscore[pos], pos))

    while frontier:  # While there is still states to explore
        current = heappop(frontier)[1]

        if heuristic(current, goal) < stepSize:  # If a current state is close enough to goal
            path = []
            while current in cameFrom:
                path.append(current)
                current = cameFrom[current]
            path.append(pos)
            path.reverse()  # Reconstruct path
            return path

        exploredSet.add(current)  # Add node to explored
        for neighbor in get_neighbors(current):  # Look through neighbors and assign gScores
            tentativeGScore = gScore[current] + heuristic(neighbor, current)
            if neighbor in exploredSet and tentativeGScore >= gScore.get(neighbor, float('inf')):  # If neighbor is not reachable or has been explored already
                continue

            if tentativeGScore < gScore.get(neighbor, float('inf')) or neighbor not in [i[1] for i in frontier]:  # If neighbor is reachable and state or state hasn't been explored
                cameFrom[neighbor] = current
                gScore[neighbor] = tentativeGScore
                fscore[neighbor] = tentativeGScore + heuristic(neighbor, goal)
                heappush(frontier, (fscore[neighbor], neighbor))  # Add neighbor to frontier

    return False

# Use this later when I can randomly generate maps. RN use same map to ensure everygthigns works
# # Initialize the robot at the starting position (0, 0)
# robot = Robot(startPosition=(0, 0))

# # Generate a random map with obstacles and define start and goal
# numRows = np.random.randint(5, 50)
# numCols = np.random.randint(5, 50)
# mapSize = (numRows, numCols)

# # change numObstacles to be dependent on mapSize
# numObstacles = np.random.randint(5, 10)
# map = generateRandomMap(mapSize, numObstacles)

# # Map for Robot (unknown everywhere)
# robotMap = initializeRobotMap(mapSize)
# position = (0, 0)

# robotMap[position] = FREE_SPACE
# robotMap[position] = FREE_SPACE

# Initialize the robot at the starting position (0, 0)
robot = Robot(startPosition=(0, 0))

# Use a fixed small map with obstacles
mapSize = (10, 10)
map = generateFixedMap()

# Map for Robot (unknown everywhere)
robotMap = initializeRobotMap(mapSize)
position = (0, 0)

robotMap[position] = FREE_SPACE

# MEAT OF THE CODE: FIND A NEW GOAL EVERYTIME BASED ON FRONTIER EXPLORING AND MOVE THERE WITH A*
iteration = 0
max_iterations = 26
while iteration < max_iterations:
    iteration += 1
    senseData = robot.sense(robotMap)
    frontiers = identifyFrontiers(robotMap)
    if not frontiers:
        break

    nearest_frontier = nearestFrontier(robot.position, frontiers)
    robot.findPath(robot.position, nearest_frontier, robotMap)
    position = tuple(robot.position)

# Visualize the actual map
path = np.array(robot.path)
plt.imshow(map, cmap='gray')
plt.plot(path[:, 1], path[:, 0], marker='o', color='r')
plt.title('Robot Path on Actual Map')
plt.show()

# Visualize the known map
plt.imshow(robotMap, cmap='gray', vmin=UNKNOWN, vmax=OBSTACLE)
plt.plot(path[:, 1], path[:, 0], marker='o', color='r')
plt.title('Robot Path on Known Map')
plt.show()