# -*- coding: utf-8 -*-
"""Autonomous Exploration.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R-vmmORLjlQRczr0p8Ov5pvMciXpOMYK

1) Create Map
"""

import numpy as np
import matplotlib.pyplot as plt
from heapq import heappop, heappush

# Constants describing map
UNKNOWN = -1
FREE_SPACE = 0
OBSTACLE = 1

# will use later after I figure out exploration algorithm
# def generateRandomMap(mapSize, numObstacles):
#     """Generates a random map with obstacles"""
#     map = np.zeros(mapSize)
#     obstacles = set()
#     while len(obstacles) < numObstacles:
#         obstacle = (np.random.randint(0, mapSize[0]), np.random.randint(0, mapSize[1]))
#         if obstacle != (0, 0) and obstacle != (mapSize[0] - 1, mapSize[1] - 1):
#             obstacles.add(obstacle)
#     for obstacle in obstacles:
#         map[obstacle] = OBSTACLE
#     return map

def generateFixedMap():
    """Generates a fixed small map with obstacles"""
    map = np.zeros((10, 10))
    obstacles = [
        (1, 2), (2, 2), (3, 2),
        (6, 5), (7, 5), (8, 5),
        (4, 8), (4, 9), (5, 9)
    ]
    for obstacle in obstacles:
        map[obstacle] = 1
    return map

def initializeRobotMap(mapSize):
    """Initializes the robot map with unknown values"""
    return np.full(mapSize, UNKNOWN)

"""2) Create Robot Class"""

class Robot:
    def __init__(self, startPosition):
        self.position = np.array(startPosition, dtype=float)
        self.path = [startPosition]
        self.sensorRange = 1  # Change to determine how big the sensor radius is
        self.step_size = 1  # Step size for continuous movement
        self.collision_threshold = 0.5  # Threshold distance to consider a collision
        self.globalSenseDict = {}
        self.infoGainDict = {}
        self.visited = set()
        self.iteration_positions = [startPosition]  # Track position at each iteration
        self.max_row = None
        self.max_col = None

    def isValidPosition(self, newPosition, map):
        """Checks if position is valid based on distance to obstacles and map boundaries"""
        if newPosition[0] < 0 or newPosition[0] >= map.shape[0] or newPosition[1] < 0 or newPosition[1] >= map.shape[1]:
            return False
        discrete_position = np.floor(newPosition).astype(int)
        if map[discrete_position[0], discrete_position[1]] == OBSTACLE:
            return False
        return True

    def expandMapIfNeeded(self, robotMap, map):
        """Expands the map size if the robot is at the boundary, but not beyond the actual map size"""
        expanded = False
        rows, cols = robotMap.shape
        actual_rows, actual_cols = map.shape
        new_robot_map = robotMap.copy()

        if self.position[0] >= rows - 1 and rows < actual_rows:
            new_robot_map = np.vstack((new_robot_map, np.full((1, cols), UNKNOWN)))
            expanded = True
        if self.position[1] >= cols - 1 and cols < actual_cols:
            new_robot_map = np.hstack((new_robot_map, np.full((new_robot_map.shape[0], 1), UNKNOWN)))
            expanded = True

        if expanded:
            print(f"Map expanded to size: {new_robot_map.shape}")
            robotMap = new_robot_map

        return robotMap

    def updateMap(self, map, robotMap):
        """Senses the environment around the robot to update RobotMap's grid knowledge (free space, obstacles, and unknown)"""
        currSenseDict = {}
        angle_resolution = 360  # Full resolution to check 360 degrees around the robot
        for angle in np.linspace(0, 2 * np.pi, angle_resolution):  # Checks 360 degrees around the robot
            for r in np.arange(0, self.sensorRange + self.step_size, self.step_size):  # Checks distance increments of sensorRange
                pos_to_check = self.position + r * np.array([np.cos(angle), np.sin(angle)])
                discrete_pos_to_check = tuple(np.round(pos_to_check).astype(int))  # Use np.round for better accuracy
                if 0 <= discrete_pos_to_check[0] < map.shape[0] and 0 <= discrete_pos_to_check[1] < map.shape[1]:  # If in-bounds, check position
                    # Expand robotMap if necessary
                    robotMap = self.expandMapIfNeeded(robotMap, map)
                    if robotMap[discrete_pos_to_check[0], discrete_pos_to_check[1]] == UNKNOWN:  # If unknown on robotMap
                        if map[discrete_pos_to_check[0], discrete_pos_to_check[1]] == OBSTACLE:  # Check actual map if obstacle
                            robotMap[discrete_pos_to_check[0], discrete_pos_to_check[1]] = OBSTACLE  # Update robotMap
                            currSenseDict[discrete_pos_to_check] = 'obstacle'  # Update Local Dict
                            self.globalSenseDict[discrete_pos_to_check] = 'obstacle'  # Update globalSenseDict for obstacle
                            break  # Stop sensing further in this direction
                        else:  # Or check if free
                            robotMap[discrete_pos_to_check[0], discrete_pos_to_check[1]] = FREE_SPACE
                            currSenseDict[discrete_pos_to_check] = 'free'
                            self.globalSenseDict[discrete_pos_to_check] = 'free'  # Update globalSenseDict for free space
                    else:  # If already known on robotMap
                        if robotMap[discrete_pos_to_check[0], discrete_pos_to_check[1]] == OBSTACLE:
                            currSenseDict[discrete_pos_to_check] = 'obstacle'
                            self.globalSenseDict[discrete_pos_to_check] = 'obstacle'  # Update globalSenseDict for obstacle
                            break  # Stop sensing further in this direction
                        else:
                            currSenseDict[discrete_pos_to_check] = 'free'
                            self.globalSenseDict[discrete_pos_to_check] = 'free'  # Update globalSenseDict for free space
                else:
                    # Update max boundaries when out of bounds detected
                    if discrete_pos_to_check[0] >= map.shape[0]:
                        self.max_row = map.shape[0] - 1
                    if discrete_pos_to_check[1] >= map.shape[1]:
                        self.max_col = map.shape[1] - 1

        return currSenseDict, robotMap

    def updateScores(self, robotMap):
        """Senses the environment around the robot to update RobotMap's grid knowledge (information gain)"""
        angle_resolution = 360  # Full resolution to check 360 degrees around the robot
        current_position = tuple(np.round(self.position).astype(int))  # Determine the current position once

        # Clear infoGainDict but preserve penalties for visited positions
        self.infoGainDict = {pos: -1000 for pos in self.visited}  # Apply heavy penalty to visited positions

        for angle in np.linspace(0, 2 * np.pi, angle_resolution):  # Checks 360 degrees around the robot
            for r in np.arange(0, self.sensorRange + self.step_size, self.step_size):  # Checks distance increments of sensorRange
                pos_to_update = self.position + r * np.array([np.cos(angle), np.sin(angle)])
                discrete_pos_to_update = tuple(np.round(pos_to_update).astype(int))  # Use np.round for better accuracy

                if 0 <= discrete_pos_to_update[0] < robotMap.shape[0] and 0 <= discrete_pos_to_update[1] < robotMap.shape[1]:  # If in-bounds, check position
                    if robotMap[discrete_pos_to_update[0], discrete_pos_to_update[1]] == FREE_SPACE:
                        if discrete_pos_to_update not in self.infoGainDict:
                            self.infoGainDict[discrete_pos_to_update] = 0
                        self.infoGainDict[discrete_pos_to_update] += 1

    def move(self, newPos, map, robotMap):
        newPos = np.array(newPos, dtype=float)
        while not np.array_equal(self.position, newPos):  # While goal hasn't been reached
            direction = np.sign(newPos - self.position)
            newPosition = self.position + direction * self.step_size
            if self.isValidPosition(newPosition, map):
                self.position = newPosition
                self.path.append(newPosition.tolist())
                self.visited.add(tuple(newPosition))
                robotMap = self.expandMapIfNeeded(robotMap, map)
                senseData, robotMap = self.updateMap(map, robotMap)  # Update map while moving
                self.updateScores(robotMap)  # Update scores while moving
            else:
                print(f"Movement blocked at: {newPosition}")
                break
        return robotMap

    def findPathAndGo(self, goal, map, robotMap):
        current_goal = goal
        while True:
            path = a_star(robotMap, self.position, current_goal, self.step_size)
            if path:
                print(f"Path found to {current_goal}: {path}")
                for pos in path:
                    robotMap = self.move(pos, map, robotMap)
                    if np.array_equal(pos, current_goal):
                        return robotMap
                    # If we find an obstacle while moving, replan the path
                    senseData, robotMap = self.updateMap(map, robotMap)
                    if tuple(pos) in self.globalSenseDict and self.globalSenseDict[tuple(pos)] == 'obstacle':
                        print(f"Obstacle encountered at {pos}. Replanning path.")
                        break
            else:
                print(f"No path found to {current_goal}")
                break
        return robotMap

"""3) Simulate Movement on Map"""

def identifyFrontiers(robotMap, senseData):
    """Identifies frontiers in the robot map based on current position"""
    frontiers = []
    currPosition = tuple(robot.position)
    for key in senseData.keys():
        if senseData[key] == 'free' and key != currPosition:
            frontiers.append(key)
    return frontiers

def bestFrontier(frontiers, infoGainDict, visited):
    """Selects the frontier with the highest information gain"""
    best_gain = float('-inf')
    best_frontier = None
    slight_punishment = -50  # Slight punishment for visited frontiers

    all_visited = True  # Flag to check if all frontiers have been visited

    for frontier in frontiers:
        if frontier in visited:
            gain = infoGainDict.get(frontier, float('-inf')) + slight_punishment  # Apply slight punishment for visited frontiers and update dictionary
            infoGainDict[frontier] = gain
        else:
            all_visited = False
            gain = infoGainDict.get(frontier, float('-inf'))

        if gain > best_gain:
            best_gain = gain
            best_frontier = frontier

    # If all frontiers are visited, apply a slight punishment but still return the best frontier
    if all_visited:
        for frontier in frontiers:
            visited.remove(frontier)  # So that it doesn't punish it with -1000
    return best_frontier

def heuristic(a, b):
    return np.linalg.norm(np.array(a) - np.array(b))

def a_star(map, pos, goal, stepSize=0.25):
    def get_neighbors(pos):
        """Explore in 8 directions for neighboring states"""
        directions = [(stepSize, 0), (-stepSize, 0), (0, stepSize), (0, -stepSize),
                      (stepSize, stepSize), (stepSize, -stepSize), (-stepSize, stepSize), (-stepSize, -stepSize)]
        neighbors = []
        for direction in directions:
            neighbor = (pos[0] + direction[0], pos[1] + direction[1])
            if 0 <= neighbor[0] < map.shape[0] and 0 <= neighbor[1] < map.shape[1] and map[int(neighbor[0]), int(neighbor[1])] != OBSTACLE:
                neighbors.append(tuple(neighbor))
        return neighbors

    pos = tuple(pos)
    goal = tuple(goal)
    exploredSet = set()
    cameFrom = {}  # Used to reconstruct path
    gScore = {pos: 0}
    fscore = {pos: heuristic(pos, goal)}
    frontier = []
    heappush(frontier, (fscore[pos], pos))

    while frontier:  # While there is still states to explore
        current = heappop(frontier)[1]

        if heuristic(current, goal) < stepSize:  # If a current state is close enough to goal
            path = []
            while current in cameFrom:
                path.append(current)
                current = cameFrom[current]
            path.append(pos)
            path.reverse()  # Reconstruct path
            return path

        exploredSet.add(current)  # Add node to explored
        for neighbor in get_neighbors(current):  # Look through neighbors and assign gScores
            tentativeGScore = gScore[current] + heuristic(neighbor, current)
            if neighbor in exploredSet and tentativeGScore >= gScore.get(neighbor, float('inf')):  # If neighbor is not reachable or has been explored already
                continue

            if tentativeGScore < gScore.get(neighbor, float('inf')) or neighbor not in [i[1] for i in frontier]:  # If neighbor is reachable and state or state hasn't been explored
                cameFrom[neighbor] = current
                gScore[neighbor] = tentativeGScore
                fscore[neighbor] = tentativeGScore + heuristic(neighbor, goal)
                heappush(frontier, (fscore[neighbor], neighbor))  # Add neighbor to frontier

    return False

def sampleNodes(robotMap, num_samples=10):
    """Samples nodes within the map to determine potential exploration points"""
    rows, cols = robotMap.shape
    samples = []
    for _ in range(num_samples):
        sample = (np.random.randint(0, rows), np.random.randint(0, cols))
        if robotMap[sample] == UNKNOWN:
            samples.append(sample)
    return samples

def pruneSampledNodes(sampled_nodes, visited, sensorRange):
    """Prunes sampled nodes that are within sensorRange to any nodes in the visited list"""
    pruned_samples = []
    for sample in sampled_nodes:
        too_close = False
        for v in visited:
            if np.linalg.norm(np.array(sample) - np.array(v)) <= sensorRange:
                too_close = True
                break
        if not too_close:
            pruned_samples.append(sample)
    return pruned_samples

def furthestNode(sampled_nodes, visited):
    """Finds the furthest node from the list of visited nodes"""
    max_distance = float('-inf')
    furthest_node = None
    for sample in sampled_nodes:
        min_distance_to_visited = min(np.linalg.norm(np.array(sample) - np.array(v)) for v in visited)
        if min_distance_to_visited > max_distance:
            max_distance = min_distance_to_visited
            furthest_node = sample
    return furthest_node

# Initialize the robot at the starting position (0, 0)
robot = Robot(startPosition=(0, 0))

# Actual map size is fixed to 5x5 with predefined obstacles
map = generateFixedMap()

# Initial robot map assumption: 5 x 5
initialMapAssumption = (5, 5)
robotMap = initializeRobotMap(initialMapAssumption)
position = (0, 0)

robotMap[position] = FREE_SPACE
robot.visited.add(position)

# MEAT OF THE CODE: FIND A NEW GOAL EVERY TIME BASED ON FRONTIER EXPLORING AND MOVE THERE WITH A*
iteration = 0
max_iterations = 20
while iteration < max_iterations:
    iteration += 1
    print(f"\nIteration: {iteration}")
    senseData, robotMap = robot.updateMap(map, robotMap)
    robot.updateScores(robotMap)
    frontiers = identifyFrontiers(robotMap, senseData)
    sampled_nodes = sampleNodes(robotMap)
    pruned_samples = pruneSampledNodes(sampled_nodes, robot.visited, robot.sensorRange)
    furthest_sampled_node = furthestNode(pruned_samples, robot.visited)

    if furthest_sampled_node:
        print(f"Furthest sampled node: {furthest_sampled_node}")
        robotMap = robot.findPathAndGo(furthest_sampled_node, map, robotMap)
    else:
        print("No valid furthest node found. Exploring frontiers instead.")
        best_frontier_to_explore = bestFrontier(frontiers, robot.infoGainDict, robot.visited)
        print(robot.infoGainDict)
        print(f"Best frontier: {best_frontier_to_explore}")
        robotMap = robot.findPathAndGo(best_frontier_to_explore, map, robotMap)

    position = tuple(robot.position)
    print(f"Current position: {position}")

print("\nGlobal Sense Dictionary:", robot.globalSenseDict)
print("Visited Nodes:", robot.visited)

# Metrics to track
numObstacles = np.sum(robotMap == 1)
numFreeSpaces = np.sum(robotMap == 0)
coverage = numObstacles + numFreeSpaces / (map.shape[0] * map.shape[1]) * 100

numObstacles = np.sum(map == 1)
#obstacleDetectionRate = len([key for key, value in robot.globalSenseDict.items() if value == 'obstacle']) / numObstacles * 100

print(f"Coverage: {coverage}")

# Visualize the actual map
path = np.array(robot.path)
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.imshow(map, cmap='gray')
plt.plot(path[:, 1], path[:, 0], marker='o', color='r')
plt.title('Robot Path on Actual Map')

# Visualize the known map
plt.subplot(1, 2, 2)
plt.imshow(robotMap, cmap='gray', vmin=UNKNOWN, vmax=OBSTACLE)
plt.plot(path[:, 1], path[:, 0], marker='o', color='r')
plt.title('Robot Path on Known Map')
plt.show()

# # Initialize the robot at the starting position (0, 0)
# robot = Robot(startPosition=(0, 0))

# # Use this later when I can randomly generate maps. RN use same map to ensure everygthigns works
# # Initialize the robot at the starting position (0, 0)
# robot = Robot(startPosition=(0, 0))

# # Generate a random map with obstacles and define start and goal
# numRows = np.random.randint(5, 15)
# numCols = np.random.randint(5, 15)
# mapSize = (numRows, numCols)

# # change numObstacles to be dependent on mapSize
# numObstacles = np.random.randint(5, 10)
# map = generateRandomMap(mapSize, numObstacles)

# # Map for Robot (unknown everywhere)
# robotMap = initializeRobotMap(mapSize)
# position = (0, 0)

# robotMap[position] = FREE_SPACE
# robotMap[position] = FREE_SPACE