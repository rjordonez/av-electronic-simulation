# -*- coding: utf-8 -*-
"""Autonomous Exploration.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R-vmmORLjlQRczr0p8Ov5pvMciXpOMYK

1) Create Map
"""

import numpy as np
import matplotlib.pyplot as plt
from heapq import heappop, heappush

# Constants describing map
UNKNOWN = -1
FREE_SPACE = 0
OBSTACLE = 1

# will use later after I figure out exploration algorithm
# def generateRandomMap(mapSize, numObstacles):
#     """Generates a random map with obstacles"""
#     map = np.zeros(mapSize)
#     obstacles = set()
#     while len(obstacles) < numObstacles:
#         obstacle = (np.random.randint(0, mapSize[0]), np.random.randint(0, mapSize[1]))
#         if obstacle != (0, 0) and obstacle != (mapSize[0] - 1, mapSize[1] - 1):
#             obstacles.add(obstacle)
#     for obstacle in obstacles:
#         map[obstacle] = OBSTACLE
#     return map

def generateFixedMap():
    """Generates a fixed small map with obstacles"""
    map = np.zeros((10, 10))
    obstacles = [
        (1, 2), (2, 2), (3, 2),
        (6, 5), (7, 5), (8, 5),
        (4, 8), (4, 9), (5, 9)
    ]
    for obstacle in obstacles:
        map[obstacle] = 1
    return map

def initializeRobotMap(mapSize):
    """Initializes the robot map with unknown values"""
    return np.full(mapSize, UNKNOWN)

"""2) Create Robot Class"""

class Robot:
    def __init__(self, startPosition):
        self.position = np.array(startPosition, dtype=float)
        self.path = [startPosition]
        self.sensorRange = 1  # Change to determine how big the sensor radius is
        self.step_size = 1  # Step size for continuous movement
        self.collision_threshold = 0.5  # Threshold distance to consider a collision
        self.globalSenseDict = {}
        self.infoGainDict = {}
        self.visited = set()

    def isValidPosition(self, newPosition, map):
        """Checks if position is valid based on distance to obstacles and map boundaries"""
        if newPosition[0] < 0 or newPosition[0] >= map.shape[0] or newPosition[1] < 0 or newPosition[1] >= map.shape[1]:
            return False
        steps = int(np.ceil(np.linalg.norm(newPosition - self.position) / self.step_size))
        for step in range(steps + 1):
            interp_position = self.position + step * (newPosition - self.position) / steps
            discrete_position = np.floor(interp_position).astype(int)
            if not (0 <= discrete_position[0] < map.shape[0] and 0 <= discrete_position[1] < map.shape[1]):
                return False
            if map[discrete_position[0], discrete_position[1]] == OBSTACLE:
                return False
        return True

    def updateMap(self, map, robotMap):
        """Senses the environment around the robot to update RobotMap's grid knowledge (free space, obstacles, and unknown)"""
        currSenseDict = {}
        angle_resolution = 360  # Full resolution to check 360 degrees around the robot
        for angle in np.linspace(0, 2 * np.pi, angle_resolution):  # Checks 360 degrees around the robot
            for r in np.arange(0, self.sensorRange + self.step_size, self.step_size):  # Checks distance increments of sensorRange
                pos_to_check = self.position + r * np.array([np.cos(angle), np.sin(angle)])
                discrete_pos_to_check = tuple(np.round(pos_to_check).astype(int))  # Use np.round for better accuracy
                if 0 <= discrete_pos_to_check[0] < map.shape[0] and 0 <= discrete_pos_to_check[1] < map.shape[1]:  # If in-bounds, check position
                    if robotMap[discrete_pos_to_check[0], discrete_pos_to_check[1]] == UNKNOWN:  # If unknown on robotMap
                        if map[discrete_pos_to_check[0], discrete_pos_to_check[1]] == OBSTACLE:  # Check actual map if obstacle
                            robotMap[discrete_pos_to_check[0], discrete_pos_to_check[1]] = OBSTACLE  # Update robotMap
                            currSenseDict[discrete_pos_to_check] = 'obstacle'  # Update Local Dict
                        else:  # Or check if free
                            robotMap[discrete_pos_to_check[0], discrete_pos_to_check[1]] = FREE_SPACE
                            currSenseDict[discrete_pos_to_check] = 'free'
                    else:  # If already known on robotMap
                        if robotMap[discrete_pos_to_check[0], discrete_pos_to_check[1]] == OBSTACLE:
                            currSenseDict[discrete_pos_to_check] = 'obstacle'
                        else:
                            currSenseDict[discrete_pos_to_check] = 'free'
                    self.globalSenseDict[discrete_pos_to_check] = currSenseDict[discrete_pos_to_check]  # Update globalSenseDict

        return currSenseDict


        return currSenseDict

    def updateScores(self, robotMap):
        """Senses the environment around the robot to update RobotMap's grid knowledge (information gain)"""
        angle_resolution = 360  # Full resolution to check 360 degrees around the robot
        current_position = tuple(np.round(self.position).astype(int))  # Determine the current position once

        # Clear infoGainDict but preserve penalties for visited positions
        self.infoGainDict = {pos: -1000 for pos in self.visited}  # Apply heavy penalty to visited positions

        for angle in np.linspace(0, 2 * np.pi, angle_resolution):  # Checks 360 degrees around the robot
            for r in np.arange(0, self.sensorRange + self.step_size, self.step_size):  # Checks distance increments of sensorRange
                pos_to_update = self.position + r * np.array([np.cos(angle), np.sin(angle)])
                discrete_pos_to_update = tuple(np.round(pos_to_update).astype(int))  # Use np.round for better accuracy

                if 0 <= discrete_pos_to_update[0] < robotMap.shape[0] and 0 <= discrete_pos_to_update[1] < robotMap.shape[1]:  # If in-bounds, check position
                    if robotMap[discrete_pos_to_update[0], discrete_pos_to_update[1]] == FREE_SPACE:
                        if discrete_pos_to_update not in self.infoGainDict:
                            self.infoGainDict[discrete_pos_to_update] = 0
                        self.infoGainDict[discrete_pos_to_update] += 1


    def move(self, newPos, map):
        newPos = np.array(newPos, dtype=float)
        while not np.array_equal(self.position, newPos):  # While goal hasn't been reached
            direction = np.sign(newPos - self.position)
            newPosition = self.position + direction * self.step_size
            if self.isValidPosition(newPosition, map):
                self.position = newPosition
                self.path.append(newPosition.tolist())
                self.visited.add(tuple(newPosition))
            else:
                print(f"Movement blocked at: {newPosition}")
                break

    def findPathAndGo(self, goal, map, robotMap):
        path = a_star(robotMap, self.position, goal, self.step_size)
        if path:
            print(f"Path found to {goal}: {path}")
            for pos in path:
                self.updateMap(map, robotMap)
                self.updateScores(robotMap)
                self.move(pos, map)
                self.globalSenseDict[tuple(pos)] = 'free'  # While moving, set everything in path to be known as free
        else:
            print(f"No path found to {goal}")

"""3) Simulate Movement on Map"""

def identifyFrontiers(robotMap, senseData, visited):
    """Identifies frontiers in the robot map based on current position"""
    frontiers = []
    currPosition = tuple(robot.position)
    for key in senseData.keys():
        if senseData[key] == 'free' and key != currPosition:  # last part is a problem if we run out of spots that have not been visited. This is because no more frontiers will be added
            frontiers.append(key)
    return frontiers

def bestFrontier(frontiers, infoGainDict):
    """Selects the frontier with the highest information gain"""
    best_gain = -1
    best_frontier = None
    for frontier in frontiers:
        gain = infoGainDict.get(frontier, 0)
        if gain > best_gain:
            best_gain = gain
            best_frontier = frontier
    return best_frontier

def heuristic(a, b):
    return np.linalg.norm(np.array(a) - np.array(b))

def a_star(map, pos, goal, stepSize=0.25):
    def get_neighbors(pos):
        """Explore in 8 directions for neighboring states"""
        directions = [(stepSize, 0), (-stepSize, 0), (0, stepSize), (0, -stepSize),
                      (stepSize, stepSize), (stepSize, -stepSize), (-stepSize, stepSize), (-stepSize, -stepSize)]
        neighbors = []
        for direction in directions:
            neighbor = (pos[0] + direction[0], pos[1] + direction[1])
            if 0 <= neighbor[0] < map.shape[0] and 0 <= neighbor[1] < map.shape[1] and map[int(neighbor[0]), int(neighbor[1])] != OBSTACLE:
                neighbors.append(tuple(neighbor))
        return neighbors

    pos = tuple(pos)
    goal = tuple(goal)
    exploredSet = set()
    cameFrom = {}  # Used to reconstruct path
    gScore = {pos: 0}
    fscore = {pos: heuristic(pos, goal)}
    frontier = []
    heappush(frontier, (fscore[pos], pos))

    while frontier:  # While there is still states to explore
        current = heappop(frontier)[1]

        if heuristic(current, goal) < stepSize:  # If a current state is close enough to goal
            path = []
            while current in cameFrom:
                path.append(current)
                current = cameFrom[current]
            path.append(pos)
            path.reverse()  # Reconstruct path
            return path

        exploredSet.add(current)  # Add node to explored
        for neighbor in get_neighbors(current):  # Look through neighbors and assign gScores
            tentativeGScore = gScore[current] + heuristic(neighbor, current)
            if neighbor in exploredSet and tentativeGScore >= gScore.get(neighbor, float('inf')):  # If neighbor is not reachable or has been explored already
                continue

            if tentativeGScore < gScore.get(neighbor, float('inf')) or neighbor not in [i[1] for i in frontier]:  # If neighbor is reachable and state or state hasn't been explored
                cameFrom[neighbor] = current
                gScore[neighbor] = tentativeGScore
                fscore[neighbor] = tentativeGScore + heuristic(neighbor, goal)
                heappush(frontier, (fscore[neighbor], neighbor))  # Add neighbor to frontier

    return False

# Initialize the robot at the starting position (0, 0)
robot = Robot(startPosition=(0, 0))

# Use a fixed small map with obstacles
mapSize = (10, 10)
map = generateFixedMap()

# Map for Robot (unknown everywhere)
robotMap = initializeRobotMap(mapSize)
position = (0, 0)

robotMap[position] = FREE_SPACE
robot.visited.add(position)

# MEAT OF THE CODE: FIND A NEW GOAL EVERY TIME BASED ON FRONTIER EXPLORING AND MOVE THERE WITH A*
iteration = 0
max_iterations = 51
while iteration < max_iterations:
    iteration += 1
    print(f"\n Iteration: {iteration}")
    senseData = robot.updateMap(map, robotMap)
    senseScores = robot.updateScores(robotMap)
    frontiers = identifyFrontiers(robotMap, senseData, robot.visited)
    print(f"Frontiers: {frontiers}")
    best_frontier_to_explore = bestFrontier(frontiers, robot.infoGainDict)
    print(robot.infoGainDict)
    print(f"Best frontier: {best_frontier_to_explore}")
    robot.findPathAndGo(best_frontier_to_explore, map, robotMap)
    position = tuple(robot.position)
    #print(f"Current position: {position}")

print("\nGlobal Sense Dictionary:", robot.globalSenseDict)
print("Visited Nodes:", robot.visited)

# Metrics to track
numObstacles = np.sum(robotMap == 1)
numFreeSpaces = np.sum(robotMap == 0)
coverage = numObstacles + numFreeSpaces / (map.shape[0] * map.shape[1]) * 100

numObstacles = np.sum(map == 1)
obstacleDetectionRate = len([key for key, value in robot.globalSenseDict.items() if value == 'obstacle']) / numObstacles * 100

print(f"Coverage: {coverage}, Obstacle Detection Rate: {obstacleDetectionRate}")

# Visualize the actual map
path = np.array(robot.path)
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.imshow(map, cmap='gray')
plt.plot(path[:, 1], path[:, 0], marker='o', color='r')
plt.title('Robot Path on Actual Map')

# Visualize the known map
plt.subplot(1, 2, 2)
plt.imshow(robotMap, cmap='gray', vmin=UNKNOWN, vmax=OBSTACLE)
plt.plot(path[:, 1], path[:, 0], marker='o', color='r')
plt.title('Robot Path on Known Map')
plt.show()

# Use this later when I can randomly generate maps. RN use same map to ensure everygthigns works
# Initialize the robot at the starting position (0, 0)
# robot = Robot(startPosition=(0, 0))

# # Generate a random map with obstacles and define start and goal
# numRows = np.random.randint(5, 50)
# numCols = np.random.randint(5, 50)
# mapSize = (numRows, numCols)

# # change numObstacles to be dependent on mapSize
# numObstacles = np.random.randint(5, 10)
# map = generateRandomMap(mapSize, numObstacles)

# # Map for Robot (unknown everywhere)
# robotMap = initializeRobotMap(mapSize)
# position = (0, 0)

# robotMap[position] = FREE_SPACE
# robotMap[position] = FREE_SPACE