# -*- coding: utf-8 -*-
"""Autonomous Exploration.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R-vmmORLjlQRczr0p8Ov5pvMciXpOMYK

1) Create Map
"""

import numpy as np
import matplotlib.pyplot as plt
from heapq import heappop, heappush

def generateRandomMap(mapSize, numObstacles):
    map = np.zeros(mapSize)
    obstacles = set()
    while len(obstacles) < numObstacles:
      obstacle = (np.random.randint(0, mapSize[0]), np.random.randint(0, mapSize[1]))
      if obstacle != (0, 0) and obstacle != (mapSize[0] - 1, mapSize[1] - 1):
        obstacles.add(obstacle)
    for obstacle in obstacles:
      map[obstacle] = 1
    return map

"""2) Create Robot Class"""

class Robot:
    def __init__(self, startPosition):
        self.position = np.array(startPosition, dtype=float)
        self.path = [startPosition]
        self.sensorRange = 1  # Change to determine how big the sensor radius is
        self.step_size = 1  # Step size for continuous movement
        self.collision_threshold = 0.5  # Threshold distance to consider a collision

    def isValidPosition(self, newPosition):
        """Checks if position is valid based on distance to obstacles and map boundaries"""
        # Check if within bounds
        if newPosition[0] < 0 or newPosition[0] >= mapSize[0] or newPosition[1] < 0 or newPosition[1] >= mapSize[1]:
            return False

        # Check if any intermediate points between current position and new position hit an obstacle
        steps = int(np.ceil(np.linalg.norm(newPosition - self.position) / self.step_size))
        for step in range(steps + 1):
            interp_position = self.position + step * (newPosition - self.position) / steps
            discrete_position = np.floor(interp_position).astype(int)
            # Check if inbounds
            if not (0 <= discrete_position[0] < mapSize[0] and 0 <= discrete_position[1] < mapSize[1]):
                return False
            # Check if an obstacle
            if map[discrete_position[0], discrete_position[1]] == 1:
                return False

        return True

    def sense(self):
        """Senses the environment around the robot in a continuous manner"""
        obstacles = set()  # Using a set to avoid duplicates
        angle_resolution = 720  # Finer angle resolution for increased detection
        for angle in np.linspace(0, 2 * np.pi, angle_resolution):  # Checks 360 degrees around the robot
            for r in np.arange(0, self.sensorRange + self.step_size, self.step_size):  # Checks distance increments of sensorRange
                pos_to_check = self.position + r * np.array([np.cos(angle), np.sin(angle)])
                discrete_pos_to_check = np.round(pos_to_check).astype(int)  # Use np.round for better accuracy
                if 0 <= discrete_pos_to_check[0] < mapSize[0] and 0 <= discrete_pos_to_check[1] < mapSize[1]:
                    if map[discrete_pos_to_check[0], discrete_pos_to_check[1]] == 1:
                        obstacles.add(tuple(discrete_pos_to_check))
                        break  # Stop checking further along this angle as an obstacle is found
        return list(obstacles)

    def move(self, newPos):
        while not np.array_equal(self.position, newPos):  # While goal hasn't been reached
          direction = np.sign(newPos - self.position)
          newPosition = self.position + direction * self.step_size
          if self.isValidPosition(newPosition):
            self.position = newPosition
            self.path.append(newPosition.tolist())
          else:
            print("Obstacle detected")
            break

    def findPath(self, start, goal):
      path = a_star(map, start, goal, self.step_size)
      if path:
        print("Path found: ", path)
        for pos in path:
          print(self.sense())
          self.move(pos)
      else:
        print("No path found")

"""3) Simulate Movement on Map"""

def heuristic(a, b):
    return np.linalg.norm(np.array(a) - np.array(b))

def a_star(map, start, goal, stepSize = 0.25):
  def get_neightbors(pos):
    """Explore in 8 directions for neighboring states"""
    directions = [(stepSize, 0), (-stepSize, 0), (0, stepSize), (0, -stepSize),
            (stepSize, stepSize), (stepSize, -stepSize), (-stepSize, stepSize), (-stepSize, -stepSize)]
    neighbors = []
    for direction in directions:
      neighbor = (pos[0] + direction[0], pos[1] + direction[1])
      if 0 <= neighbor[0] < map.shape[0] and 0 <= neighbor[1] < map.shape[1] and map[int(neighbor[0]), int(neighbor[1])] != 1:
        neighbors.append(neighbor)
    return neighbors

  exploredSet = set()
  cameFrom = {}  # Used to reconstruct path
  gScore = {start: 0}
  fscore = {start: heuristic(start, goal)}
  frontier = []
  heappush(frontier, (fscore[start], start))

  while frontier:  # While there is still states to explore
    current = heappop(frontier)[1]

    if heuristic(current, goal) < stepSize:  # If a current state is close enough to goal
      path = []
      while current in cameFrom:
        path.append(current)
        current = cameFrom[current]
      path.append(start)
      path.reverse() # Reconstruct path
      return path

    exploredSet.add(current)  # Add node to explored
    for neighbor in get_neightbors(current):  # Look through neighbors and assign gScores
      tentativeGScore = gScore[current] + heuristic(neighbor, current)
      if neighbor in exploredSet and tentativeGScore >= gScore.get(neighbor, float('inf')):  # If neighbor is not reachable or has been explored already
        continue

      if tentativeGScore < gScore.get(neighbor, float('inf')) or neighbor not in [i[1] for i in frontier]:  # If neighbor is reachable and state or state hasn't been explored
        cameFrom[neighbor] = current
        gScore[neighbor] = tentativeGScore
        fscore[neighbor] = tentativeGScore + heuristic(neighbor, goal)
        heappush(frontier, (fscore[neighbor], neighbor))  # Add neighbor to frontier

  return False

# Initialize the robot at the starting position (0, 0)
robot = Robot(startPosition=(0, 0))

# Define the start and goal positions


# Generate a random map with obstacles and define start and goal
numRows = np.random.randint(5, 50)
numCols = np.random.randint(5, 50)
mapSize = (numRows, numCols)

# change numObstacles to be dependent on mapSize
numObstacles = np.random.randint(5, 10)
map = generateRandomMap(mapSize, numObstacles)
start = (0, 0)
goal = (mapSize[0] - 1, mapSize[1] - 1)

# Find the path from start to goal
robot.findPath(start, goal)

path = np.array(robot.path)
plt.imshow(map, cmap='gray')
plt.plot(path[:, 1], path[:, 0], marker='o', color='r')
plt.title('Robot Path')
plt.show()

# Tomorrow: add in A* movement to see if obstacle tracking, obstacle avoidance, and path tracking work. Potentially add random map generator